#' fcsim
#' 
#' This function similate differential expression fold change level
#' @param n.gene total number of genes
#' @param de.id index of differentially expressed genes
#' @param fc.mean location parameter for fold change (normal distribution)
#' @param fc.sd scale parameter for fold change (normal distribution)
#' @references Zappia, L., Phipson, B., & Oshlack, A. (2017). Splatter: Simulation of single-cell RNA sequencing data. Genome Biology, 18(1). https://doi.org/10.1186/s13059-017-1305-0 
#' @import stats
#' 
fcsim <- function (n.gene, de.id, fc.mean, fc.sd){
  n.de <- length(de.id)
  fc <- rnorm(n.de, fc.mean, fc.sd)
  fc.all <- rep(1, n.gene)
  fc.all[de.id] <- fc
  return(fc.all)
}

#' GeneScape_par
#' 
#' This function simulate parameters for single cell RNAseq data simulation with complicated differential expression.
#' @param nCells number of cells
#' @param nGroups number of cell groups
#' @param groups group information for cells
#' @param lib.size library size for cells
#' @param lib.size.mean location parameter for library size (log-normal distribution)
#' @param lib.size.sd scale parameter for library size (log-normal distribution)
#' @param de.fc.mat differential expression fold change matrix, could be generated by this function
#' @param nGenes number of genes
#' @param gene.mean.shape shape parameter for mean expression level (Gamma distribution)
#' @param gene.mean.rate rate parameter for mean expression level (Gamma distribution)
#' @param gene.means mean gene expression levels
#' @param zero.inflat vector of zero inflation paramters
#' @param add.zero.inflat whether to add zero inflation
#' @param zero.inflat.times the zero inflation paramter is simulated as zero.inflat.times / (1 + exp(gene.means))
#' @param de.n number of differentially expressed genes in each cell type. Should be a integer or a vector of length nGroups
#' @param de.share number of shared DE genes between neighbor cell types. Should be a vector of length (nGroups - 1)
#' @param de.id the index of genes that are DE across cell types. Should be a list of vectors. 
#'        Each vector corresponds to a cell type. With non-null value of de.id, de.n and de.share would be ignored.
#' @param de.fc.mean the location parameter for the fold change of DE genes. Should be a number, a vector of length nGroups 
#            or a list of vectors with exactly same structure as de.id (or the structure defined by de.n and de.share)
#' @param de.fc.sd the scale parameter for fold change (log-normal distribution). Should be a number or a vector of length nGroups
#' @param add.sub whether to add sub-cell-types
#' @param sub.major the major cell types correspond to the sub-cell-types
#' @param sub.prop proportion of sub-cell-types in the corresponding major cell type
#' @param sub.group cell index for sub-cell-types. With non-null sub.group specified, sub.prop would be ignored.
#' @param sub.de.n number of differentially expressed genes in each sub-cell-type compared to the corresponding major cell type. Should be a integer or a vector of length sub.major
#' @param sub.de.id the index of additional differentially expressed genes between sub-cell-types and the corresponding major cell types
#' @param sub.de.common whether the additional differential expression structure should be same for all sub-cell-types
#' @param sub.de.fc.mean similar to de.fc.mean, but for addtional differentially expressed genes in sub-cell-types
#' @param sub.de.fc.sd similar to de.fc.sd, but for addtional differentially expressed genes in sub-cell-types
#' @return A list of simulation parameters: vector of cell groups, vector of cell library size, gene expression 
#' parameter (zero-inflated poisson model), and matrix of differentially expression fold changes.
#' @references Zappia, L., Phipson, B., & Oshlack, A. (2017). Splatter: Simulation of single-cell RNA sequencing data. Genome Biology, 18(1). https://doi.org/10.1186/s13059-017-1305-0 
#' @details 
#' @examples
#' set.seed(1)
#' para <- GeneScape_par()
#' @import stats
#' @export
#' 

GeneScape_par <- function(nCells = 6000, nGroups = NULL, groups = NULL, 
                          lib.size = NULL, lib.size.mean = 10000, lib.size.sd = 2000, 
                          de.fc.mat = NULL, nGenes = 5000, gene.mean.shape = 0.3, gene.mean.rate = 0.15, gene.means = NULL,
                          zero.inflat = NULL, add.zero.inflat = TRUE, zero.inflat.times = 0.5,
                          de.n = 50, de.share = NULL, de.id = NULL, de.fc.mean = 1, de.fc.sd = 0.2, 
                          add.sub = FALSE, sub.major = NULL, sub.prop = 0.1, sub.group = NULL, sub.de.n = 20, 
                          sub.de.id = NULL, sub.de.common = FALSE, sub.de.fc.mean = 1, sub.de.fc.sd = 0.2){
  if (is.null(de.fc.mat)){
    if (is.null(nGroups)){
      nGroups <- 4
    }
    
    if (is.null(groups)){
      groups <- rep_len(1:nGroups, nCells)
    } else if ((length(unique(groups)) != nGroups) & (is.null(de.fc.mat))){
      stop("Number of unique groups does not match nGroup.")
    } else if ((max(groups) != nGroups) & (is.null(de.fc.mat))){
      stop("groups is not encoded by integers starting from 1.")
    }
    
    if (is.null(lib.size)){
      if (length(lib.size.mean) == 1){
        lib.size.mean <- rep(lib.size.mean, nGroups)
      } else if (length(lib.size.mean) != nGroups){
        stop("Length of lib.size.mean does not match nGroup.")
      }
      
      if (length(lib.size.sd) == 1){
        lib.size.sd <- rep(lib.size.sd, nGroups)
      } else if (length(lib.size.sd) != nGroups){
        stop("Length of lib.size.sd does not match nGroup.")
      }
      
      lib.size <- rnorm(nCells, lib.size.mean[groups], lib.size.sd[groups])   # library size
    }
    
    
    if (is.null(gene.means)){
      gene.means <- rgamma(nGenes, shape = gene.mean.shape, rate = gene.mean.rate)   # gene expression level
    } else if (length(gene.means) != nGenes){
      stop("Length of gene.means does not match nGenes.")
    }
    
    if (!add.zero.inflat){
      zero.inflat <- rep(0, nGenes)
    } else {
      if (is.null(zero.inflat)){
        zero.inflat <- zero.inflat.times / (1 + exp(gene.means))
      } else if (length(zero.inflat) != nGenes){
        stop("Length of zero.inflat does not match nGenes.")
      }
    }
    
    if (is.null(de.id)){
      if (length(de.n) == 1){
        de.n <- rep(de.n, nGroups)
      } else if (length(de.n) != nGroups){
        stop("Length of de.n does not match nGroup.")
      }
      
      if (is.null(de.share)){
        de.share <- rep(0, nGroups - 1)
      } else if (length(de.share) != (nGroups - 1)){
        stop("Length of de.share does not match nGroup - 1.")
      }
      
      de.id.set <- sample(1:nGenes, (sum(de.n) - sum(de.share)))
      de.id <- list()
      pos <- 0
      for (i in 1:nGroups){
        if (i == 1){
          de.id[[i]] <- de.id.set[1:de.n[1]]
          pos <- de.n[1]
        } else {
          de.id[[i]] <- de.id.set[(pos - de.share[i-1] + 1):(pos - de.share[i-1] + de.n[i])]
          pos <- pos - de.share[i-1] + de.n[i]
        }
      }
    } else {
      if (length(de.id) != nGroups){
        stop("Wrong size of de.id. It should be a list of length nGroups.")
      } 
    }
    
    if (length(de.fc.sd) == 1){
      de.fc.sd <- rep(de.fc.sd, nGroups)
    } else if (length(de.fc.sd) != nGroups){
      stop("Length of de.fc.sd does not match nGroup.")
    }
    
    if (!is.list(de.fc.mean)){
      if (length(de.fc.mean) == 1){
        de.fc.mean <- rep(de.fc.mean, nGroups)
      } else if (length(de.fc.mean) != nGroups){
        stop("Length of de.fc.mean does not match nGroup.")
      } 
      de.fc.mean.new <- list()
      for (i in 1:nGroups){
        de.fc.mean.new[[i]] <- rep(de.fc.mean[i], length(de.id[[i]]))
      }
      de.fc.mean <- de.fc.mean.new
    } else {
      if (length(de.fc.mean) != nGroups){
        stop("Wrong size of de.fc.mean. It should be a list of length nGroups or a vector of length nGroups or a single number.")
      } 
    }
    
    group.fc <- matrix(1, ncol = nGroups, nrow = nGenes)
    for (idx in seq_len(nGroups)) {
      de.fc <- fcsim(nGenes, de.id[[idx]], de.fc.mean[[idx]], de.fc.sd[idx])
      group.fc[, idx] <- de.fc
    }   # differential expression fold change parameter
    
    group.fc.total <- group.fc
    
  } else {
    if (nrow(de.fc.mat) != nGenes){
      stop("Size of de.fc.mat does not match nGenes.")
    } else if ((is.null(groups)) | (is.null(nGroups))){
      stop("de.fc.mat needs to be provided together with groups and nGroups.")
    } else if ((ncol(de.fc.mat) != max(groups)) | (ncol(de.fc.mat) < nGroups)){
      stop("Number of unique groups (including subgroups) does not match de.fc.mat.")
    }
    
    if (length(lib.size.mean) == 1){
      lib.size.mean <- rep(lib.size.mean, nGroups)
    } else if (length(lib.size.mean) != nGroups){
      stop("Length of lib.size.mean does not match nGroup.")
    }
    
    if (length(lib.size.sd) == 1){
      lib.size.sd <- rep(lib.size.sd, nGroups)
    } else if (length(lib.size.sd) != nGroups){
      stop("Length of lib.size.sd does not match nGroup.")
    }
    
    groups.old <- groups
    if (add.sub){
      for (i in 1:length(sub.major)){
        groups.old[groups.old == (i + nGroups)] <- sub.major[i]
      }
    }
    
    if (is.null(lib.size)){
      if (length(lib.size.mean) == 1){
        lib.size.mean <- rep(lib.size.mean, nGroups)
      } else if (length(lib.size.mean) != nGroups){
        stop("Length of lib.size.mean does not match nGroup.")
      }
      
      if (length(lib.size.sd) == 1){
        lib.size.sd <- rep(lib.size.sd, nGroups)
      } else if (length(lib.size.sd) != nGroups){
        stop("Length of lib.size.sd does not match nGroup.")
      }
      
      lib.size <- rnorm(nCells, lib.size.mean[groups.old], lib.size.sd[groups.old])   # library size
    }
    
    
    if (is.null(gene.means)){
      gene.means <- rgamma(nGenes, shape = gene.mean.shape, rate = gene.mean.rate)   # gene expression level
    } else if (length(gene.means) != nGenes){
      stop("Length of gene.means does not match nGenes.")
    }
    
    if (!add.zero.inflat){
      zero.inflat <- rep(0, nGenes)
    } else {
      if (is.null(zero.inflat)){
        zero.inflat <- zero.inflat.times / (1 + exp(gene.means))
      } else if (length(zero.inflat) != nGenes){
        stop("Length of zero.inflat does not match nGenes.")
      }
    }
    
    group.fc.total <- group.fc <- de.fc.mat
    
    de.id <- list()
    for (i in 1:nGroups){
      de.id[[i]] <- which(de.fc.mat[,i] != 1)
    }
  }
  
  # simulate the sub-cell-types
  if (add.sub){
    if (is.null(sub.major)){
      sub.major <- 1:nGroups
    } else if ((!is.integer(sub.major)) | (max(sub.major) > nGroups)) {
      stop("Index of sub groups' corresponding major cell types exceed nGroup.")
    }
    
    if (is.null(sub.group)){
      for (i in 1:length(sub.major)){
        temp <- which(groups == sub.major[i])
        sub.group[[i]] <- sample(temp, size = round(sub.prop * length(temp)))
      }
    }
    
    if (length(sub.group) != length(sub.major)){
      stop("Index of sub groups' corresponding major cell types does not match sub type cell ids.")
    }
    
    if (is.null(sub.de.id)){
      if (length(sub.de.n) == 1){
        sub.de.n <- rep(sub.de.n, length(sub.major))
      } else if (length(sub.de.n) != length(sub.major)){
        stop("Length of sub.de.n does not match length of sub.major.")
      }
      
      sub.de.id.set <- sample(setdiff(1:nGenes, unique(unlist(de.id))), sum(sub.de.n))
      sub.de.id <- list()
      pos <- 0
      for (i in 1:length(sub.major)){
        if (i == 1){
          sub.de.id[[i]] <- sub.de.id.set[1:sub.de.n[1]]
          pos <- sub.de.n[1]
        } else {
          sub.de.id[[i]] <- sub.de.id.set[(pos + 1):(pos + sub.de.n[i])]
          pos <- pos + sub.de.n[i]
        }
      }
    } else {
      if (length(sub.de.id) != length(sub.major)){
        stop("Wrong size of sub.de.id. It should be a list of length nGroups.")
      } 
    }
    
    
    if (length(sub.de.fc.sd) == 1){
      sub.de.fc.sd <- rep(sub.de.fc.sd, length(sub.major))
    } else if (length(sub.de.fc.sd) != length(sub.major)){
      stop("Length of sub.de.fc.sd does not match length of sub.major.")
    }
    
    if (!is.list(sub.de.fc.mean)){
      if (length(sub.de.fc.mean) == 1){
        sub.de.fc.mean <- rep(sub.de.fc.mean, length(sub.major))
      } else if (length(sub.de.fc.mean) != length(sub.major)){
        stop("Length of sub.de.fc.mean does not match length of sub.major.")
      } 
      sub.de.fc.mean.new <- list()
      for (i in 1:length(sub.major)){
        sub.de.fc.mean.new[[i]] <- rep(sub.de.fc.mean[i], length(sub.de.id[[i]]))
      }
      sub.de.fc.mean <- sub.de.fc.mean.new
    }
    
    sub.group.fc <- matrix(1, ncol = length(sub.major), nrow = nGenes)
    for (i in 1:length(sub.major)){
      sub.group.fc[,i] <- group.fc[, sub.major[i]]
    }
    if (sub.de.common){
      sub.de.fc <- fcsim(nGenes, sub.de.id[[1]], sub.de.fc.mean[[1]], sub.de.fc.sd[1])
      sub.group.fc[sub.de.id[[1]], ] <- matrix(sub.de.fc[sub.de.id[[1]]], nrow = length(sub.de.id[[1]]), ncol = length(sub.major), byrow = F)
    } else {
      for (idx in 1:length(sub.major)) {
        sub.de.fc <- fcsim(nGenes, sub.de.id[[idx]], sub.de.fc.mean[[idx]], sub.de.fc.sd[idx])
        sub.group.fc[sub.de.id[[idx]], idx] <- sub.de.fc[sub.de.id[[idx]]]
      }
    }
    group.fc.total <- cbind(group.fc, sub.group.fc)
  }
  
  genepar <- data.frame(lam = gene.means, pi = zero.inflat)
  genepar <- as.matrix(genepar)
  
  groups.new <- groups
  if (add.sub){
    for (i in 1:length(sub.major)){
      groups.new[sub.group[[i]]] <- i + nGroups
    }
  }
  
  return(list(groups = as.integer(groups.new),
              library.size = lib.size, 
              genepar = genepar,
              de_mat = group.fc.total))
}


#' estimate_zip
#' 
#' This function estimate zero-inflated poisson distribution parameters from data vector
#' @param datavec target data vector
#' @return a vector of zero-inflated poisson distribution parameters. first element 
#' is mean parameter, while second element is zero-inflation parameter.
#' @references S. Dencks, M. Piepenbrock and G. Schmitz, "Assessing Vessel Reconstruction 
#' in Ultrasound Localization Microscopy by Maximum Likelihood Estimation of a Zero-Inflated 
#' Poisson Model," in IEEE Transactions on Ultrasonics, Ferroelectrics, and Frequency 
#' Control, vol. 67, no. 8, pp. 1603-1612, Aug. 2020, doi: 10.1109/TUFFC.2020.2980063.
#' @import lamW
#' 
estimate_zip <- function(datavec){
  t1 <- sum(datavec > 0)
  if (t1 == 0){
    return(c(lam = 0, pi = 0))
  }
  t2 <- sum(datavec)
  n <- length(datavec)
  temp <- t2 / t1
  lam <- lambertW0(-temp * exp(-temp)) + temp
  pi <- t2 / n / lam
  if (pi > 1){
    pi <- 1
    lam <- t2 / n
  }
  return(c(lam = lam, pi = pi))
}


#' GeneScape_est
#' 
#' This function estimate zero-inflated poisson distribution parameters from data
#' @param data target gene (row) by cell (column) data matrix
#' @param groups group of the cells
#' @return list of two gene (row) by group (column) matrices. first matrix contains 
#' the mean parameter, while second matrix contains zero inflation parameters.
#' 
GeneScape_est <- function(data, groups = NULL){
  rowm <- apply(data, 1, estimate_zip)
  rowm <- t(rowm)
  if (is.null(groups)){
    dem <- matrix(1, nrow = nrow(data), ncol = 1)
    rownames(dem) <- rownames(data)
    colnames(dem) <- "1"
    groups <- rep(1, ncol(data))
  } else {
    ug <- unique(groups)
    ug <- ug[order(ug)]
    dem <- matrix(1, nrow = nrow(data), ncol = length(ug))
    rownames(dem) <- rownames(data)
    colnames(dem) <- as.character(ug)
    for (i in 1:length(ug)){
      tempid <- which(groups == ug[i])
      tempdata <- data[, tempid]
      temprowm <- rowMeans(tempdata)
      dem[,i] <- temprowm / rowm$lam
    }
  }
  lib.size <- colSums(data)
  return(list(groups = groups,
              library.size = lib.size, 
              genepar = rowm,
              de_mat = dem))
}


#' GeneScape_sim
#' 
#' This function generate single cell RNAseq data using simulation parameter.
#' @param para simulation parameter estimated by GeneScape_est or simulated by GeneScape_par
#' @param add.path whether to add pathways (correlated genes)
#' @param path.n number of pathways included. Should be a integer.
#' @param path.size number of correlated genes (length of pathway). Should be a number or a vector of length path.n
#' @param path.cor correlation parameters
#' @param path.id gene index of correlated (pathway) genes. Should be a list of vectors, with each vector represents a pathway. With non-null value of path.id, path.n would be ignored.
#' @param band.width No correlation exists if distance of 2 genes are further than band_width in a pathway
#' @param add.hub whether to add hub genes
#' @param hub.n number of hub genes included. Should be a integer.
#' @param hub.size number of genes correlated to the hub gene. Should be a number or a vector of length hub.n
#' @param hub.cor correlation parameters between hub genes and their correlated genes
#' @param hub.id gene index of hub genes. Should be a list of vectors. With non-null value of hub.id, hub.n would be ignored.
#' @param hub.fix user defined genes correlated to hub genes (others are randomly selected). Should be a list of vectors of length hub.n or same as hub.id.
#' @return A list of read count data, cell groups, cell library size, gene mean expression, gene differential expression rate, pathway genes and hub gene indices.
#' @references Zappia, L., Phipson, B., & Oshlack, A. (2017). Splatter: Simulation of single-cell RNA sequencing data. Genome Biology, 18(1). https://doi.org/10.1186/s13059-017-1305-0 
#' @details 
#' @import corpcor
#' @import MASS
#' @import stats
#' @examples
#' set.seed(1)
#' para <- GeneScape_par()
#' data <- GeneScape_sim(para)
#' @export
#' 

GeneScape_sim <- function(para,
                          add.path = FALSE, path.n = 4, path.size = 20, path.cor = 0.7, path.id = NULL, band.width = 10,
                          add.hub = FALSE, hub.n = 10, hub.size = 20, hub.cor = 0.4, hub.id = NULL, hub.fix = NULL){
  genepar <- para$genepar
  libsize <- para$library.size
  nCells <- length(libsize)
  nGenes <- nrow(genepar)
  group <- para$groups
  de_mat <- para$de_mat
  ug <- unique(group)
  ng <- length(ug)
  p <- nrow(genepar)
  
  gene.means.all <- matrix(genepar[,1], nrow = nGenes, ncol = nCells, byrow = FALSE) * 
    as.matrix(de_mat[, group])
  gene.means.lib <- gene.means.all * 
    matrix(libsize / colSums(gene.means.all), nrow = nGenes, ncol = nCells, byrow = TRUE)
  true.counts <- matrix(rpois(as.numeric(nGenes) * as.numeric(nCells), lambda = gene.means.lib), 
                        nrow = nGenes, ncol = nCells, byrow = FALSE)
  
  # simulate the correlated genes
  path.list <- list()
  if (add.path){
    if (length(path.size) == 1){
      path.size <- rep(path.size, path.n)
    } else if (length(path.size) != path.n){
      stop("Length of path.size does not match path.n.")
    }
    
    if (length(path.cor) == 1){
      path.cor <- rep(path.cor, path.n)
    } else if (length(path.cor) != path.n){
      stop("Length of path.cor does not match path.n.")
    }
    if (is.null(path.id)){
      temp <- 1:nGenes
      non.de <- which(rowSums(de_mat == 1) == ncol(de_mat))
      if (length(non.de) > sum(path.size)){
        temp <- non.de
      }
      path.id.set <- sample(temp, sum(path.size))
      path.id <- list()
      pos <- 0
      for (i in 1:path.n){
        path.id[[i]] <- path.id.set[(pos + 1):(pos + path.size[i])]
        pos <- pos + path.size[i]
      }
    }
    
    for (j in 1:length(path.cor)){
      l <- length(path.id[[j]])
      S <- matrix(0, l, l)
      diag(S) <- 1
      for (i in 1:(l-1)){
        for (k in (i+1):l){
          temp <- path.cor[j] ^ (k-i)
          if ((k - i) <= band.width){
            S[i, k] <- temp
            S[k, i] <- temp
          }
        }
      } # build covariance matrix
      e1 <- min(eigen(S)$values)
      if (e1 <= 0){
        S <- S + diag(0.1 - e1, nrow(S))
      } # deal with covariance matrix that are not positive definite
      sim <- mvrnorm(nCells, rep(0, l), S)
      psim <- pnorm(sim)
      temp <- qpois(t(psim), gene.means.lib[path.id[[j]],])
      true.counts[path.id[[j]],] <- temp
    }
    path.list <- path.id
  }
  
  # simulate the hub genes
  hub.list <- list()
  if (add.hub){
    if (length(hub.size) == 1){
      hub.size <- rep(hub.size, hub.n)
    } else if (length(hub.size) != hub.n){
      stop("Length of hub.size does not match hub.n.")
    }
    
    if (length(hub.cor) == 1){
      hub.cor <- rep(hub.cor, hub.n)
    } else if (length(hub.cor) != hub.n){
      stop("Length of hub.cor does not match hub.n.")
    }
    
    if (is.null(hub.fix)){
      hub.fix <- replicate(hub.n, numeric(0))
    } else if ((length(hub.fix) != hub.n) & (length(hub.fix) != length(hub.id))){
      stop("Length of hub.fix does not match hub.n.")
    }
    
    if (is.null(hub.id)){
      temp <- 1:nGenes
      non.de <- which(rowSums(de_mat == 1) == ncol(de_mat))
      if (add.path){
        non.de <- setdiff(non.de, unique(unlist(path.id)))
      }
      if (length(non.de) > sum(hub.size)){
        temp <- non.de
      }
      hub.id <- sample(temp, hub.n)
    }

    gene.set.left <- setdiff(temp, hub.id)
    for (j in 1:length(hub.id)){
      l <- hub.size[j]
      S <- matrix(0, l, l)
      S[1,] <- hub.cor[j]
      S[,1] <- hub.cor[j]
      diag(S) <- 1  # build covariance matrix
      S1 <- make.positive.definite(S) # deal with covariance matrix that are not positive definite
      sim <- mvrnorm(nCells, rep(0, l), S1)
      psim <- pnorm(sim)
      hub.pos <- sample(gene.set.left, l-length(hub.fix[[j]]), replace = FALSE)
      hub.pos <- c(hub.id[j], hub.fix[[j]], hub.pos)
      gene.set.left <- setdiff(gene.set.left, hub.pos)
      hub.list[[j]] <- hub.pos
      temp <- qpois(t(psim), gene.means.lib[hub.pos,])
      true.counts[hub.pos,] <- temp
    }
  }
  
  return(list(counts = true.counts, groups = group,
              library.size = libsize, gene.mean.exp = genepar[,1],
              de.fc = de_mat, path.list = path.list, hub.list = hub.list))
}